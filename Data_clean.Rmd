---
title: "Data_clean"
author: "Sglatt"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r set Git}
# usethis::create_from_github(
#  "https://github.com/Sfglatt/Simulate-recovery.git",
#  destdir = "Github/Simulate_recovery"
# )
```


```{r recode remove duplicates and merge}
# datasets on OSF: 

R_S1 <- read_xlsx("Sample_1.xlsx") # on OSF

R_S2 <- read_xlsx("RESST_S2.xlsx") # the de-identified dataset is on OSF, however, I'm  using one with a 'worker ID column' that is not publicly available (to merge with sample 3)

R_S3 <- read_xlsx("RESST_S3.xlsx") # the de-identified dataset is on OSF, however, I'm  using one with a 'worker ID column' that is not publicly available (to merge with sample 2)

R_S4 <- read_xlsx("Sample_4.xlsx") # on OSF

# S2 and S3 have 204 overlapping participants from test-retest } merge datasets

# Merge datasets based on worker ID (masked from public data per cloudresearch/IRB guidelines)
merged_data <- merge(R_S2, R_S3, by = "workerID", all = TRUE)

unique_data <- merged_data[!(duplicated(merged_data$workerID) | duplicated(merged_data$workerID, fromLast = TRUE)), ] # n = 466. Good (341 [sample 2] + 329 [sample 3] = 670, - 204 [duplicates from test-retest] = 466)

## now  merge variables and label all new merged variables with ".m"

### SBQ-R variables ###

# checking if the SQ-R variables are coded the same way in the original datasets so that we can merge them. 
# SBQ-R item one 
summary(unique_data$Q45.x) # range 1-6 
summary(unique_data$Q45.y) # range 1-6
# ready to be merged

# SBQ-R item two
summary(unique_data$Q47.x) # range 0-4
summary(unique_data$Q47.y) # range 1-5
# not coded the same way. recode 0-4 to 1-5: 
unique_data <- unique_data %>%
  mutate(Q47.x.n = Q47.x + 1) # new column "Q47.x.n"
summary(unique_data$Q47.x.n) # range 1-5
# ready to be merged 

# SBQ-R item three 
summary(unique_data$Q49.x) # range 1-5
summary(unique_data$Q49.y) # range 1-5
# ready to be merged

# SBQ-R item four
summary(unique_data$Q51.x) # range 0-6
summary(unique_data$Q51.y) # range 0-7
# check frequency of Q51.y to understand codes. 
frequency_Q51.y <- table(unique_data$Q51.y)
frequency_Q51.y # there are no 6's in the responses. all 7's should be recoded to 6. 
unique_data <- unique_data %>%
  mutate(Q51.y.n = ifelse(Q51.y == 7, 6, Q51.y)) # recode 7 as 6 in the Q51.y column and create a new column Q51.y.n
frequency_Q51.y.n <- table(unique_data$Q51.y.n)
frequency_Q51.y.n

# Now, we can merge SBQ-R variables 

# Merge Q45 (item 1)
unique_data$Q45.m <- ifelse(!is.na(unique_data$Q45.x), unique_data$Q45.x, unique_data$Q45.y)

# Merge Q47 (item 2)
unique_data$Q47.m <- ifelse(!is.na(unique_data$Q47.x.n), unique_data$Q47.x.n, unique_data$Q47.y)

# Merge Q49 (item 3)
unique_data$Q49.m <- ifelse(!is.na(unique_data$Q49.x), unique_data$Q49.x, unique_data$Q49.y)

# Merge Q51 (item 4)
unique_data$Q51.m <- ifelse(!is.na(unique_data$Q51.x), unique_data$Q51.x, unique_data$Q51.y.n)

# merged SBQ-R variables.
summary(unique_data$Q45.m)
summary(unique_data$Q47.m)
summary(unique_data$Q49.m)
summary(unique_data$Q51.m)

# merge recovery variables 
unique_data$R1.m <- ifelse(!is.na(unique_data$R1.x), unique_data$R1.x, unique_data$R1.y)
unique_data$R2.m <- ifelse(!is.na(unique_data$R2.x), unique_data$R2.x, unique_data$R2.y)
unique_data$R3.m <- ifelse(!is.na(unique_data$R3.x), unique_data$R3.x, unique_data$R3.y)
unique_data$R4.m <- ifelse(!is.na(unique_data$R4.x), unique_data$R4.x, unique_data$R4.y)
unique_data$R5.m <- ifelse(!is.na(unique_data$R5.x), unique_data$R5.x, unique_data$R5.y)
unique_data$R6.m <- ifelse(!is.na(unique_data$R6.x), unique_data$R6.x, unique_data$R6.y)
unique_data$R7.m <- ifelse(!is.na(unique_data$R7.x), unique_data$R7.x, unique_data$R7.y)
unique_data$R8.m <- ifelse(!is.na(unique_data$R8.x), unique_data$R8.x, unique_data$R8.y)
unique_data$R9.m <- ifelse(!is.na(unique_data$R9.x), unique_data$R9.x, unique_data$R9.y)
unique_data$R10.m <- ifelse(!is.na(unique_data$R10.x), unique_data$R10.x, unique_data$R10.y)
unique_data$R11.m <- ifelse(!is.na(unique_data$R11.x), unique_data$R11.x, unique_data$R11.y)
unique_data$R12.m <- ifelse(!is.na(unique_data$R12.x), unique_data$R12.x, unique_data$R12.y)
unique_data$R13.m <- ifelse(!is.na(unique_data$R13.x), unique_data$R13.x, unique_data$R13.y)
unique_data$R14.m <- ifelse(!is.na(unique_data$R14.x), unique_data$R14.x, unique_data$R14.y)
unique_data$R15.m <- ifelse(!is.na(unique_data$R15.x), unique_data$R15.x, unique_data$R15.y)
unique_data$R16.m <- ifelse(!is.na(unique_data$R16.x), unique_data$R16.x, unique_data$R16.y)
unique_data$R17.m <- ifelse(!is.na(unique_data$R17.x), unique_data$R17.x, unique_data$R17.y)
unique_data$R18.m <- ifelse(!is.na(unique_data$R18.x), unique_data$R18.x, unique_data$R18.y)
unique_data$R19.m <- ifelse(!is.na(unique_data$R19.x), unique_data$R19.x, unique_data$R19.y)
unique_data$R20.m <- ifelse(!is.na(unique_data$R20.x), unique_data$R20.x, unique_data$R20.y)
unique_data$R21.m <- ifelse(!is.na(unique_data$R21.x), unique_data$R21.x, unique_data$R21.y)
# now we have 21 recovery variables with ".m" for merged 

# mew dataframe with just the merged SBQ-R variables, and merged RESST variables
selected_S2_3 <- unique_data %>%
  dplyr::select(R1.m, R2.m, R3.m, R4.m, R5.m, R6.m, R7.m, R8.m, R9.m, R10.m, R11.m, R12.m, R13.m, R14.m, R15.m, R16.m,  R17.m, R18.m, R19.m, R20.m, R21.m,
         Q45.m, Q47.m, Q49.m, Q51.m)
head(selected_S2_3)

# now merge this dataset with S1 and S4. 
# make sure the SBQ-R variables are coded in the same way as the merged S2-S3 above. 

##  sample one

summary(R_S1$Q45) # 2-6
# same coding as merged S2-S3. 

summary(R_S1$Q47) # 1-5
# same coding as merged S2-S3. 

summary(R_S1$Q49) # 11-15
# not the same coding as merged S2-S3. 
# recode so 11 = 1, 12 = 2, 13 = 3, 14 = 4, 15 = 5. 
R_S1 <- R_S1 %>%
  mutate(Q49.m = case_when(
    Q49 == 11 ~ 1,
    Q49 == 12 ~ 2,
    Q49 == 13 ~ 3,
    Q49 == 14 ~ 4,
    Q49 == 15 ~ 5
  ))
summary(R_S1$Q49.m) # 1-5. ready to be merged. 

summary(R_S1$Q51) # 1-7
# needs to be recoded to 0-6. 
R_S1 <- R_S1 %>%
  mutate(Q51.m = Q51 - 1) 
summary(R_S1$Q51)
summary(R_S1$Q51.m) # now 0-6. ready to be merged. 

##  sample four

summary(R_S4$Q45) # 1-6
# same coding as merged S2-S3 and S1

summary(R_S4$Q47) # 1-5
# same coding as merged S2-S3 and S1

summary(R_S4$Q49) # 1-5
# same coding as merged S2-S3 and S1

summary(R_S4$Q51) # 1-7
# needs to be recoded to 0-6. 
R_S4 <- R_S4 %>%
  mutate(Q51.m = Q51 - 1) 
summary(R_S4$Q51)
summary(R_S4$Q51.m) # now 0-6. ready to be merged. 

## all SBQ-R variables are uniform across S1, merged S2-S3, and S4 ##

selected_S1 <- R_S1 %>%
  dplyr::select(R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15, R16,  R17, R18, R19, R20, R21,
         Q45, Q47, Q49.m, Q51.m)
head(selected_S1)

selected_S4 <- R_S4 %>%
  dplyr::select(R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15, R16,  R17, R18, R19, R20, R21,
         Q45, Q47, Q49, Q51.m)
head(selected_S4)

selected_S2_3 <- unique_data %>%
  dplyr::select(R1.m, R2.m, R3.m, R4.m, R5.m, R6.m, R7.m, R8.m, R9.m, R10.m, R11.m, R12.m, R13.m, R14.m, R15.m, R16.m,  R17.m, R18.m, R19.m, R20.m, R21.m,
         Q45.m, Q47.m, Q49.m, Q51.m)
head(selected_S2_3)

# now merge the "selected" dataframes. These have all RESST and SBQ-R variables for the 1,1319 participants. 

# Remove .m label so that all columns have the same name and can be merged.
selected_S1 <- selected_S1 %>%
  rename_all(~gsub(".m$", "", .))

selected_S2_3 <- selected_S2_3 %>%
  rename_all(~gsub(".m$", "", .))

selected_S4 <- selected_S4 %>%
  rename_all(~gsub(".m$", "", .))

# merge 
combined_Rs <- bind_rows(selected_S1, selected_S2_3, selected_S4)
head(combined_Rs)
glimpse(combined_Rs) # all data complete
nrow(combined_Rs) # 1,319
is.na(combined_Rs) # no NA


# with the combined dataset, recode SBQ-R variables in line with Osman et al. 2001 to see average SBQ-R scores, etc. 

# SBQ-R 2 and SBQ-R 4 do not need to be recoded. 

# item 1: 
combined_Rs <- combined_Rs %>%
  mutate(Q45c = case_when(
    Q45 %in% c(3, 4) ~ 3,
    Q45 %in% c(5, 6) ~ 4, 
    TRUE ~ Q45 # Keep other values unchanged so 1 = 1 and 2 = 2 in line with SBQ-R scoring
  ))

summary(combined_Rs$Q45c)

# item 3: 
combined_Rs <- combined_Rs %>%
  mutate(Q49c = case_when(
    Q49 %in% c(2, 3) ~ 2,
    Q49 %in% c(4, 5) ~ 3,
    TRUE ~ Q49  # Keep other values unchanged so 1 = 1 in line with SBQ-R scoring
  ))

summary(combined_Rs$Q49c)

# SBQ-R total scores: 
combined_Rs <- combined_Rs %>%
  mutate(SBQR_total = 
           Q45c # recoded item 1
         + Q47  # item 2 
         + Q49c # recoded item 3
         + Q51) # item 4

summary(combined_Rs$SBQR_total)
# minimum = 3
# maximum = 18
# average = 10.14   
# median = 10
sum(combined_Rs$SBQR_total >= 7) / length(combined_Rs$SBQR_total) * 100 # % met the risk cutoff
sum(combined_Rs$Q45 >= 3) / length(combined_Rs$Q45) * 100 # % endorsed a suicide plan or attempt history 
sum(combined_Rs$Q45 >= 5) / length(combined_Rs$Q45) * 100 # % endorsed a suicide attempt history 
sum(combined_Rs$Q45 %in% c(3, 4)) / length(combined_Rs$Q45) * 100 # % endorsed a suicide plan history
sum(combined_Rs$Q47 >= 3) / length(combined_Rs$Q47) * 100 # % endorsed suicidal thoughts "somewhat" or >

head(combined_Rs)
# write.csv(combined_Rs, 'Combined_samples_simulations_1319_2.18.csv') # save a csv with the 1,319 participants with uniform recovery and SBQ-R variables (raw, recoded, total). 
```

```{r make groups}

### create groups of current suicide and former suicide ###

RESST_sim_sui <- combined_Rs %>% filter(Q51 > 3) # a data frame with people who perceive a LIKELY future suicide attempt (n = 274)

RESST_sim_noFSA <- combined_Rs %>% filter(Q51 < 4) # a data frame with people who perceive an UNLIKELY future suicide attempt (n = 1045)

RESST_sim_no_SI <- RESST_sim_noFSA %>% filter(Q47 < 3) # a data frame with people who perceive an UNLIKELY future suicide attempt AND "never" or "rarely" past year suicidal ideation  (n = 508)

RESST_sim_lifetime_risk <- RESST_sim_no_SI %>% filter(Q45 > 2) # a dataset with people who perceive an UNLIKELY future suicide attempt AND "never" or "rarely" past year suicidal ideation AND endorse a lifetime suicide plan/attempt history (n = 371)
nrow(RESST_sim_lifetime_risk)

# n = 274 and n = 371 are the final groups, isolated from 1,319 RESST participants across samples 1-4. 

### SBQ-R total scores and summaries for current suicide group ###
summary(RESST_sim_sui$SBQR_total) 
# all individuals meet the SBQ-R cutoff for suicide risk and average is over the cutoff. 
sum(RESST_sim_sui$SBQR_total >= 7) / length(RESST_sim_sui$SBQR_total) * 100 # % met or exceeded the risk cutoff
sum(RESST_sim_sui$Q45 >= 3) / length(RESST_sim_sui$Q45) * 100 # % endorsed a suicide plan or attempt history
sum(RESST_sim_sui$Q47 >= 3) / length(RESST_sim_sui$Q47) * 100 # % endorsed ideation "somewhat" or >

### SBQ-R total scores and summaries for former suicide group ###
summary(RESST_sim_lifetime_risk$SBQR_total) 
sum(RESST_sim_lifetime_risk$SBQR_total >= 7) / length(RESST_sim_lifetime_risk$SBQR_total) * 100 # % met or exceeded the risk cutoff
sum(RESST_sim_lifetime_risk$Q45 >= 3) / length(RESST_sim_lifetime_risk$Q45) * 100 # % endorsed a suicide plan or attempt 
sum(RESST_sim_lifetime_risk$Q47 >= 3) / length(RESST_sim_lifetime_risk$Q47) * 100 # % endorsed ideation "somewhat" or > 

# most individuals meet the SBQ-R cutoff for suicide risk and the average is over the cutoff. This makes sense since the SBQ-R uses lifetime features as part of the total score - and we only included people in this group with NO perceived likelihood of a future suicide attempt AND "rarely" or "never" suicidal thoughts AND a lifetime history of a suicide plan or attempt. the lifetime variables  contribute to the total risk score. this is why we only used item 4 to categorize CURRENT suicide risk - since the other variables are past-year or lifetime. 

```

```{r Prepare variables}
# The personal recovery items range from 1 to 5: 

# Does not describe me (1)
# Describes me slightly well (2)
# Describes me moderately well (3)
# Describes me very well (4)
# Describes me extremely well (5)

### recode the items so that 1 and 2 = 0; 3, 4, 5 = 1. Items need to be binary for the planned analyses.

RESST_sim_sui_di <- RESST_sim_sui %>%
  mutate_at(vars(R1:R21), ~ifelse(. %in% c(1, 2), 0, 1))

colSums(RESST_sim_sui_di[, paste0("R", 1:21)] == 1) # frequencies of 1's on items


RESST_sim_lifetime_risk_di <- RESST_sim_lifetime_risk %>%
  mutate_at(vars(R1:R21), ~ifelse(. %in% c(1, 2), 0, 1))
```


